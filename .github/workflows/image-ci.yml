name: Image Lambda CI

on:
  push:
    branches: ["main"]
    paths:
      - "src/**"
      - "requirements.txt"
      - "Dockerfile"
      - "infra/image/**"
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: sa-east-1
      REPO_NAME: artifact-fn

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Usa SUAS credenciais (sem role_arn)
      - name: Configure AWS (Access Keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # --- Terraform primeiro: garante/cria o ECR e expõe a URI ---
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8

      - name: Terraform Init (image)
        working-directory: infra/image
        run: terraform init -upgrade
            
      # tenta liberar lock preso no DDB antes de aplicar
      - name: Force unlock stale Terraform lock (best-effort)
        working-directory: infra/image
        env:
          TF_LOCK_TABLE: terraform-locks
          TF_LOCK_KEY: ddd-state-terraform/artifact-lib-image/terraform.tfstate
        run: |
          set -e
          # jq geralmente já existe no runner; se quiser garantir, descomente:
          # sudo apt-get update && sudo apt-get install -y jq

          ITEM_JSON=$(aws dynamodb get-item \
            --table-name "$TF_LOCK_TABLE" \
            --key "{\"LockID\":{\"S\":\"$TF_LOCK_KEY\"}}")

          INFO=$(echo "$ITEM_JSON" | jq -r '.Item.Info.S // empty')
          if [ -n "$INFO" ]; then
            LOCK_ID=$(echo "$INFO" | jq -r '.ID // empty')
            if [ -n "$LOCK_ID" ]; then
              echo "Found stale lock id: $LOCK_ID — forcing unlock"
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          else
            echo "No lock item found in $TF_LOCK_TABLE for $TF_LOCK_KEY"
          fi

      # Terraform Apply (create/ensure ECR)
      - name: Terraform Apply (create/ensure ECR)
        working-directory: infra/image
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          terraform apply \
            -auto-approve \
            -input=false \
            -lock-timeout=5m \
            -target=aws_ecr_repository.lambda

      - name: Get ECR URI from Terraform output
        id: tfout
        working-directory: infra/image
        run: |
          URI=$(terraform output -raw repository_url)
          echo "URI=$URI" | tee -a $GITHUB_ENV
          echo "uri=$URI" >> $GITHUB_OUTPUT

      # --- Login no ECR ---
      - name: Login no ECR
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      # --- Build & Push ---
      # DICA: se seu Dockerfile usa 'COPY app.py .' mas o arquivo está fora de infra/image,
      # use contexto '.' (raiz) e mantenha o Dockerfile com -f infra/image/Dockerfile
      - name: Build & Push da imagem
        env:
          REPO_URI: ${{ steps.tfout.outputs.uri }}
          GIT_SHA: ${{ github.sha }}
        run: |
        
          SHORT=${GIT_SHA::7}
          # Se o seu Dockerfile copia arquivos que estão fora de infra/image, use contexto '.' :
          docker build -t "$REPO_URI:$SHORT" -f infra/image/Dockerfile .
          docker push "$REPO_URI:$SHORT"
          echo "TAG=$SHORT" >> $GITHUB_ENV

      # Terraform Apply (update image tag)
      - name: Terraform Apply (update image tag)
        working-directory: infra/image
        env:
          TAG: ${{ env.TAG }}
        run: |
          terraform apply \
            -auto-approve \
            -input=false \
            -lock-timeout=5m \
            -var="image_tag=${TAG}"
